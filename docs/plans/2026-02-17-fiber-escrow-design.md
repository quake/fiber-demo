# Fiber Escrow Design

## Overview

An escrow trading system based on Fiber Network Hold Invoice. The arbiter holds the preimage, buyer's funds are locked in a hold invoice, and after confirming fulfillment, the preimage is released to the seller to complete payment.

## Use Case

General goods trading - buyers and sellers transact physical/virtual goods, buyer confirms receipt before releasing funds, and the arbiter only intervenes when there is a dispute.

## Key Decisions

| Decision | Choice |
|----------|--------|
| Confirmation mechanism | Buyer confirms first, arbiter handles disputes |
| Timeout handling | Auto-confirm on timeout to protect seller interests |
| Dispute resolution | Simple binary choice (full payment or full refund) |
| Preimage management | Generated and held by arbiter |
| Project structure | Shared fiber-core, independent fiber-escrow |
| UI design | Single service, multi-role (suitable for demo) |

---

## Architecture

```
fiber-demo/
├── fiber-core/                    # Shared library
│   └── src/
│       ├── fiber/                 # FiberClient trait + MockFiberClient
│       ├── crypto/                # Preimage, PaymentHash
│       └── types/                 # Common types
├── fiber-game/                    # Game demo (existing)
│   └── crates/
│       ├── fiber-game-core/       # Game-specific logic
│       ├── fiber-game-oracle/
│       └── fiber-game-player/
└── fiber-escrow/                  # Escrow demo (new)
    └── crates/
        └── fiber-escrow-service/  # Single service, multi-role UI
            ├── src/
            │   └── main.rs
            └── static/
                └── index.html
```

---

## Data Model

```rust
/// User
struct User {
    id: UserId,
    username: String,
    balance_shannons: i64,  // Can be negative (for demo purposes)
}

/// Product
struct Product {
    id: ProductId,
    seller_id: UserId,
    title: String,
    description: String,
    price_shannons: u64,
    status: ProductStatus,
}

enum ProductStatus {
    Available,
    Sold,
}

/// Order
struct Order {
    id: OrderId,
    product_id: ProductId,
    seller_id: UserId,
    buyer_id: UserId,
    amount_shannons: u64,
    
    // Generated by Arbiter
    preimage: Preimage,
    payment_hash: PaymentHash,
    
    // State transitions
    status: OrderStatus,
    created_at: Timestamp,
    expires_at: Timestamp,      // Auto-confirm timeout
    
    // Dispute
    dispute: Option<Dispute>,
}

enum OrderStatus {
    WaitingPayment,    // Waiting for buyer payment
    Funded,            // Funds locked (hold invoice paid)
    Shipped,           // Seller has shipped
    Completed,         // Buyer confirmed/timed out, preimage released
    Disputed,          // Under dispute
    Refunded,          // Arbiter ruled for refund
}

struct Dispute {
    reason: String,
    created_at: Timestamp,
    resolution: Option<DisputeResolution>,
}

enum DisputeResolution {
    ToSeller,  // Release payment to seller
    ToBuyer,   // Refund to buyer
}
```

---

## API Endpoints

### User Management

```
POST /api/user/register
     Body: { username }
     Response: { user_id, username }

GET  /api/user/me
     Header: X-User-Id: <user_id>
     Response: { user_id, username, balance_shannons }
```

### Products

```
POST /api/products
     Body: { title, description, price_shannons }
     Response: { product_id }

GET  /api/products
     Response: { products: [...] }  // All available products

GET  /api/products/mine
     Response: { products: [...] }  // Products created by current user
```

### Orders

```
POST /api/orders
     Body: { product_id }
     Response: { order_id, payment_hash, amount_shannons, expires_at }

GET  /api/orders/mine
     Response: { orders: [...] }  // Orders as buyer or seller

POST /api/orders/{id}/pay
     Response: { status }
     Effect: Simulate hold invoice payment, lock funds

POST /api/orders/{id}/ship
     Response: { status }
     Effect: Seller marks as shipped

POST /api/orders/{id}/confirm
     Response: { status, preimage }
     Effect: Release preimage, seller receives payment

POST /api/orders/{id}/dispute
     Body: { reason }
     Response: { status }
```

### Arbiter

```
GET  /api/arbiter/disputes
     Response: { disputes: [...] }

POST /api/arbiter/disputes/{order_id}/resolve
     Body: { resolution: "seller" | "buyer" }
     Response: { status }
```

### System

```
POST /api/system/tick
     Body: { seconds: 3600 }  // Simulate time passage
     Response: { expired_orders: [...] }
     Effect: Check timed-out orders, auto-confirm
```

---

## Web UI

Single page app with user identity switch at top, tabs for different modules.

```
┌─────────────────────────────────────────────────────────────┐
│  Fiber Escrow Demo              [User: alice ▼] [Balance: 5000]│
├─────────────────────────────────────────────────────────────┤
│  [Market]  [My Orders]  [My Products]  [Arbiter]             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ═══ Market ═══                                             │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │
│  │ iPhone 15    │  │ MacBook Pro  │  │ AirPods      │       │
│  │ Seller: bob  │  │ Seller: carol│  │ Seller: bob  │       │
│  │ 1000 shannons    │  │ 5000 shannons    │  │ 500 shannons     │       │
│  │ [Buy]        │  │ [Buy]        │  │ [Buy]        │       │
│  └──────────────┘  └──────────────┘  └──────────────┘       │
│                                                             │
│  ═══ My Orders ═══                                          │
│  | Product   | Amount | Status  | Actions                |  │
│  | iPhone 15 | 1000   | Shipped | [Confirm] [Dispute]    |  │
│  | AirPods   | 500    | Waiting | [Pay]                  |  │
│                                                             │
│  ═══ My Products ═══                                        │
│  [+ Create Product]                                         │
│  | Product   | Price | Status    |                       |  │
│  | USB Cable | 100   | Available |                       |  │
│                                                             │
│  ═══ Arbiter Panel ═══                                      │
│  | Order | Buyer | Seller | Reason      | Actions          |│
│  | #123  | alice | bob    | Not received| [Pay Seller] [Refund Buyer]|│
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### UI Features

1. **User Switch** - Dropdown to select user (alice/bob/carol/arbiter)
2. **Market** - Browse all purchasable products, click to buy
3. **My Orders** - View orders as buyer, can pay/confirm receipt/dispute
4. **My Products** - View products as seller and related orders, can ship
5. **Arbiter Panel** - View all disputes, rule for payment or refund

---

## Core Flow

### Normal Flow

```
Buyer                    Service                   Seller
  │                         │                         │
  │                    [Seller creates product]       │
  │                         │<──POST /products────────│
  │                         │                         │
  │──GET /products─────────>│                         │
  │<───[Product list]───────│                         │
  │                         │                         │
  │──POST /orders──────────>│                         │
  │   {product_id}          │                         │
  │                   [Generate preimage]             │
  │                   [Calculate payment_hash]        │
  │<──{order_id, payment_hash}                        │
  │                         │                         │
  │──POST /orders/{id}/pay─>│                         │
  │   [Simulate: create     │                         │
  │    hold invoice and     │                         │
  │    lock funds]          │                         │
  │                   [status: Funded]                │
  │                         │                         │
  │                         │<──POST /orders/{id}/ship│
  │                   [status: Shipped]               │
  │                         │                         │
  │──POST /orders/{id}/confirm──>│                    │
  │                   [Release preimage to seller]    │
  │                   [Seller settles invoice]        │
  │                   [status: Completed]             │
  │   [-1000 shannons]          │──[+1000 shannons]──────────>│
```

### Timeout Auto-Confirm

```
Buyer                    Service                   Seller
  │                         │                         │
  │   [Order status: Shipped]                         │
  │                         │                         │
  │   [Buyer takes no action...]                      │
  │                         │                         │
  │                   [POST /system/tick]             │
  │                   [Order timeout detected]        │
  │                   [Auto-release preimage]         │
  │                   [status: Completed]             │
  │   [-1000 shannons]          │──[+1000 shannons]──────────>│
```

### Dispute Flow

```
Buyer                    Service                   Arbiter
  │                         │                         │
  │──POST /orders/{id}/dispute──>│                    │
  │   {reason: "Not received"}   │                    │
  │                   [status: Disputed]              │
  │                         │                         │
  │                         │<──GET /arbiter/disputes─│
  │                         │───[Dispute list]───────>│
  │                         │                         │
  │                         │<──POST /resolve─────────│
  │                         │   {resolution: "buyer"} │
  │                   [Cancel hold invoice]           │
  │                   [status: Refunded]              │
  │   [+refund]             │                         │
```

---

## Implementation Plan

### Phase 1: Project Structure Refactoring

1. Create `fiber-core/` shared library
2. Extract common code from `fiber-game-core`:
   - `fiber/` (FiberClient trait, MockFiberClient)
   - `crypto/` (Preimage, PaymentHash)
3. Update `fiber-game` to depend on `fiber-core`

### Phase 2: Escrow Service Implementation

1. Create `fiber-escrow/` workspace
2. Implement data models (User, Product, Order)
3. Implement API endpoints
4. Implement timeout check logic

### Phase 3: Web UI

1. Implement single-page UI
2. User switching functionality
3. Implement each tab's features
4. Real-time status updates (polling)

### Phase 4: Testing

1. Unit tests
2. E2E test documentation
3. Manual demo verification

---

## Demo Script

Demo script to showcase the complete flow:

1. **Start service**: `cargo run --bin fiber-escrow-service`
2. **Switch to bob** → Create product "iPhone 15" (1000 shannons)
3. **Switch to alice** → Browse market → Buy iPhone → Pay
4. **Switch to bob** → View orders → Click ship
5. **Switch to alice** → Confirm receipt
6. **Verify balances**: alice -1000, bob +1000

Dispute demo:
1. Repeat steps 1-4 above
2. **alice** initiates dispute: "Not received"
3. **Switch to arbiter** → View disputes → Rule refund to buyer
4. **Verify balances**: alice refunded, bob did not receive payment

---

## Next Steps

1. Confirm design is correct
2. Create implementation plan
3. Begin coding
